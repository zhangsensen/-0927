#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Robust ranking for strategies using full-frequency scan outputs.

Input: all_freq_scan_*.csv generated by real_backtest.run_production_backtest
Output: robust_ranking_<ts>.csv in the same folder, plus stdout top-20 preview.

Robust Score (default):
  score = w_mean*mean_sharpe + w_p20*p20_sharpe - w_std*std_sharpe 
          - w_dd*max(0, (abs(mean_max_dd)-0.25)) - w_turn*mean_turnover
Where defaults: w_mean=0.4, w_p20=0.6, w_std=0.3, w_dd=0.1, w_turn=0.0

Also emits diagnostic columns: best_sharpe/freq, sharpe_p50, n_freq_ge_0.5, mean/max ann, etc.

Usage:
  python robust_rank_from_allfreq.py <path_to_all_freq_scan_csv>
If omitted, it tries to autodetect the latest results_combo_wfo/*/all_freq_scan_*.csv.
"""
from __future__ import annotations
import sys
import re
from pathlib import Path
import os
import pandas as pd

W_MEAN = float(os.environ.get('ROBUST_W_MEAN', 0.4))
W_P20  = float(os.environ.get('ROBUST_W_P20',  0.6))
W_STD  = float(os.environ.get('ROBUST_W_STD',  0.3))
W_DD   = float(os.environ.get('ROBUST_W_DD',   0.1))
W_TURN = float(os.environ.get('ROBUST_W_TURN', 0.0))

PENALTY_DD_REF = float(os.environ.get('ROBUST_DD_REF', 0.25))  # penalize only if worse than -25%
GOOD_SHARPE_TH = float(os.environ.get('ROBUST_GOOD_SHARPE', 0.5))

PREF_FREQ_SET = set([6,7,8,9,10,11,12,13,21])  # recommended band when choosing freq


def _latest_allfreq_csv(root: Path) -> Path | None:
    """Auto-pick the latest full all-frequency scan CSV.

    Heuristic: prefer files without 'backup' in the name to avoid selecting
    subset/backup artifacts like '*_top100_backup.csv'.
    """
    cands = sorted(root.glob('results_combo_wfo/*/all_freq_scan_*.csv'))
    if not cands:
        return None
    # Filter out obvious backup/subset files if present
    filtered = [p for p in cands if 'backup' not in p.name.lower()]
    target_list = filtered if filtered else cands
    return target_list[-1]


def _extract_ts(path: Path) -> str:
    m = re.search(r'(\d{8}_\d{6})', path.name)
    if m:
        return m.group(1)
    # fallback to parent folder name
    m = re.search(r'(\d{8}_\d{6})', str(path))
    return m.group(1) if m else 'unknown'


def robust_rank(df: pd.DataFrame) -> pd.DataFrame:
    # required columns
    required = ['combo', 'sharpe', 'annual_ret', 'max_dd', 'test_freq', 'avg_turnover']
    for c in required:
        if c not in df.columns:
            if c == 'avg_turnover':
                df['avg_turnover'] = 0.0
            else:
                raise ValueError(f'missing column: {c}')

    by_combo = []
    for combo, g in df.groupby('combo'):
        g = g.copy()
        # aggregate stats across frequencies
        sharpe_mean = g['sharpe'].mean()
        sharpe_std  = g['sharpe'].std(ddof=0)
        sharpe_p20  = g['sharpe'].quantile(0.2)
        sharpe_p50  = g['sharpe'].quantile(0.5)
        ann_mean    = g['annual_ret'].mean()
        ann_max     = g['annual_ret'].max()
        dd_mean     = g['max_dd'].mean()  # negative numbers, e.g., -0.28
        turn_mean   = g['avg_turnover'].mean()

        # best sharpe and its freq
        idx_best = g['sharpe'].idxmax()
        best_sharpe = g.loc[idx_best, 'sharpe']
        best_freq   = int(g.loc[idx_best, 'test_freq']) if pd.notna(g.loc[idx_best, 'test_freq']) else None

        # count good frequencies (>= threshold)
        n_good = int((g['sharpe'] >= GOOD_SHARPE_TH).sum())

        # DD penalty only if worse than ref (more negative)
        dd_pen = max(0.0, abs(dd_mean) - PENALTY_DD_REF)

        score = (
            W_MEAN * sharpe_mean +
            W_P20  * sharpe_p20  -
            W_STD  * (sharpe_std if pd.notna(sharpe_std) else 0.0) -
            W_DD   * dd_pen -
            W_TURN * turn_mean
        )

        # recommended freq: prefer 21 if not worse than median; else pick best within PREF set; else global best
        reco_freq = best_freq
        sharpe_21 = None
        if 21 in set(g['test_freq'].dropna().astype(int).tolist()):
            sharpe_21 = float(g.loc[g['test_freq']==21, 'sharpe'].iloc[0])
            if sharpe_21 >= sharpe_p50:
                reco_freq = 21
        if reco_freq != 21:
            # choose best freq among preferred set if any
            g_pref = g[g['test_freq'].isin(PREF_FREQ_SET)]
            if len(g_pref)>0:
                idxp = g_pref['sharpe'].idxmax()
                reco_freq = int(g_pref.loc[idxp, 'test_freq'])

        by_combo.append({
            'combo': combo,
            'robust_score': score,
            'sharpe_mean': sharpe_mean,
            'sharpe_std': sharpe_std,
            'sharpe_p20': sharpe_p20,
            'sharpe_p50': sharpe_p50,
            'best_sharpe': best_sharpe,
            'best_freq_sharpe': best_freq,
            'sharpe_21': sharpe_21,
            'n_freq_ge_0_5': n_good,
            'annual_mean': ann_mean,
            'annual_max': ann_max,
            'max_dd_mean': dd_mean,
            'turnover_mean': turn_mean,
            'recommended_freq': reco_freq,
        })
    out = pd.DataFrame(by_combo)
    out = out.sort_values(['robust_score','sharpe_mean','sharpe_p20','best_sharpe'], ascending=[False, False, False, False])
    return out


if __name__ == '__main__':
    import os
    root = Path(__file__).resolve().parents[2]  # etf_strategy/
    
    if len(sys.argv) >= 2:
        csv_path = Path(sys.argv[1])
    else:
        cand = _latest_allfreq_csv(root)
        if not cand:
            print('Cannot find results_combo_wfo/*/all_freq_scan_*.csv, please pass a path explicitly.')
            sys.exit(2)
        csv_path = cand

    assert csv_path.exists(), f'CSV not found: {csv_path}'
    df = pd.read_csv(csv_path)

    # guard: ensure test_freq exists
    tf = 'test_freq' if 'test_freq' in df.columns else ('freq' if 'freq' in df.columns else None)
    if tf != 'test_freq':
        if tf is None:
            raise ValueError('Neither test_freq nor freq column found')
        df = df.rename(columns={tf:'test_freq'})

    out = robust_rank(df)

    ts = _extract_ts(csv_path)
    out_path = csv_path.parent / f'robust_ranking_{ts}.csv'
    out.to_csv(out_path, index=False)

    print(f'âœ… Robust ranking saved: {out_path}')
    print('\nTop 20 preview:')
    print(out.head(20).to_string(index=False))
