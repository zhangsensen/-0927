---
alwaysApply: false
---

# 性能基准测试约束标准
# Quantitative Performance Benchmarking Requirements

## ⚡ 性能基准要求

### 因子计算性能
- **小规模** (<500样本 × 20因子): ≥ 831 factors/second
- **中等规模** (1000样本 × 50因子): ≥ 864 factors/second
- **大规模** (2000样本 × 100因子): ≥ 686 factors/second
- **超大规模** (5000样本 × 200因子): ≥ 370 factors/second

### 内存使用限制
- **因子生成**: 峰值内存使用 < 500MB
- **筛选过程**: 峰值内存使用 < 1GB
- **回测分析**: 峰值内存使用 < 2GB
- **报告生成**: 峰值内存使用 < 100MB

### 响应时间要求
- **单因子计算**: < 10ms
- **批量因子生成**: < 30秒
- **完整筛选流程**: < 60秒
- **报告生成**: < 5秒

## 📊 VectorBT 性能标准

### 核心操作性能
```python
# 性能基准测试示例
def benchmark_factor_calculation():
    # 要求: 10-50x 性能提升
    with vectorbt.Replayer() as replay:
        portfolio = vbt.Portfolio.from_signals(factor_data)
        # 必须在目标时间内完成
        assert portfolio.calc_time() < 1.0  # 1秒内完成

def benchmark_memory_usage():
    # 要求: 40-60% 内存使用减少
    old_memory = get_memory_usage()
    optimized_memory = calculate_factors_optimized()
    improvement = (old_memory - optimized_memory) / old_memory
    assert improvement >= 0.4  # 40%以上提升
```

### 批量处理要求
- **禁止**: 逐个因子循环计算
- **要求**: 批量向量化操作
- **优化**: 并行处理，内存映射

### 缓存策略
- **因子缓存**: 计算结果必须缓存
- **数据缓存**: 常用数据内存缓存
- **智能失效**: 基于数据变化的缓存失效

## 🔍 性能监控要求

### 关键指标监控
```python
# 实时性能监控
class PerformanceMonitor:
    def __init__(self):
        self.metrics = {
            'calculation_time': [],
            'memory_usage': [],
            'cache_hit_rate': [],
            'error_count': []
        }

    def monitor_calculation(self, func_name, start_time, end_time, memory_usage):
        execution_time = end_time - start_time
        self.metrics['calculation_time'].append(execution_time)
        self.metrics['memory_usage'].append(memory_usage)

        # 性能告警
        if execution_time > TARGET_TIME:
            self.alert_slow_function(func_name, execution_time)
        if memory_usage > MEMORY_LIMIT:
            self.alert_high_memory(func_name, memory_usage)
```

### 性能回归测试
- **基准测试**: 定期运行性能基准测试
- **回归检测**: 新版本不能降低性能
- **性能分析**: 识别性能瓶颈
- **优化建议**: 提供具体优化建议

## ⚠️ 性能违规检测

### 常见性能问题
```python
# ❌ 性能反模式
def slow_factor_calculation(data):
    results = []
    for factor in data.columns:
        # 逐个计算，性能差
        result = expensive_calculation(data[factor])
        results.append(result)
    return results

# ✅ 性能优化模式
def fast_factor_calculation(data):
    # 批量向量化计算
    return vectorbt.Portfolio.from_signals(data).stats()
```

### 内存泄漏检测
- **对象引用**: 检查循环引用
- **内存增长**: 监控内存使用增长趋势
- **垃圾回收**: 及时释放大对象
- **内存碎片**: 避免频繁的内存分配/释放

### 计算复杂度检查
- **时间复杂度**: 算法复杂度分析
- **空间复杂度**: 内存使用复杂度评估
- **嵌套循环**: 避免深层嵌套循环
- **递归调用**: 递归深度和栈空间管理

## 📈 性能优化策略

### 算法优化
- **向量化**: 使用 NumPy/VectorBT 向量化操作
- **并行化**: 利用多核处理器
- **预计算**: 预计算可重用的中间结果
- **延迟计算**: 按需计算，避免不必要计算

### 数据结构优化
- **内存布局**: 优化数据内存布局
- **数据类型**: 使用适当的数据类型
- **索引优化**: 优化数据访问模式
- **缓存友好**: 设计缓存友好的数据结构

### 编译优化
- **JIT编译**: 使用 Numba JIT 加速
- **C扩展**: 关键函数 C 扩展
- **Cython**: Cython 优化关键路径
- **并行库**: 使用高性能并行库

## 🎯 性能达标验证

### 性能测试流程
1. **基准测试**: 建立性能基准线
2. **回归测试**: 验证性能不退化
3. **压力测试**: 大规模数据测试
4. **优化验证**: 优化效果验证
5. **持续监控**: 生产环境性能监控

### 性能报告要求
- **执行时间**: 详细执行时间分析
- **内存使用**: 内存使用分析和优化建议
- **瓶颈识别**: 性能瓶颈识别和解决方案
- **优化建议**: 具体优化建议和实施计划

### 性能改进计划
- **短期优化**: 立即可实施的优化措施
- **中期优化**: 需要设计和实施的优化
- **长期优化**: 架构级别的性能优化
- **持续改进**: 建立持续性能改进机制

## 🔧 性能工具配置

### 性能分析工具
```python
# 性能分析工具配置
PROFILING_TOOLS = {
    'cProfile': 'Python内置性能分析器',
    'memory_profiler': '内存使用分析器',
    'line_profiler': '代码行级性能分析',
    'py-spy': 'Python性能分析工具'
}
```

### 监控仪表板
- **实时监控**: 实时性能指标监控
- **历史趋势**: 性能历史趋势分析
- **告警机制**: 性能问题自动告警
- **可视化报告**: 性能数据可视化展示

这些性能约束确保系统满足量化交易的高性能要求，支持实时交易决策。# 性能基准测试约束标准
# Quantitative Performance Benchmarking Requirements

## ⚡ 性能基准要求

### 因子计算性能
- **小规模** (<500样本 × 20因子): ≥ 831 factors/second
- **中等规模** (1000样本 × 50因子): ≥ 864 factors/second
- **大规模** (2000样本 × 100因子): ≥ 686 factors/second
- **超大规模** (5000样本 × 200因子): ≥ 370 factors/second

### 内存使用限制
- **因子生成**: 峰值内存使用 < 500MB
- **筛选过程**: 峰值内存使用 < 1GB
- **回测分析**: 峰值内存使用 < 2GB
- **报告生成**: 峰值内存使用 < 100MB

### 响应时间要求
- **单因子计算**: < 10ms
- **批量因子生成**: < 30秒
- **完整筛选流程**: < 60秒
- **报告生成**: < 5秒

## 📊 VectorBT 性能标准

### 核心操作性能
```python
# 性能基准测试示例
def benchmark_factor_calculation():
    # 要求: 10-50x 性能提升
    with vectorbt.Replayer() as replay:
        portfolio = vbt.Portfolio.from_signals(factor_data)
        # 必须在目标时间内完成
        assert portfolio.calc_time() < 1.0  # 1秒内完成

def benchmark_memory_usage():
    # 要求: 40-60% 内存使用减少
    old_memory = get_memory_usage()
    optimized_memory = calculate_factors_optimized()
    improvement = (old_memory - optimized_memory) / old_memory
    assert improvement >= 0.4  # 40%以上提升
```

### 批量处理要求
- **禁止**: 逐个因子循环计算
- **要求**: 批量向量化操作
- **优化**: 并行处理，内存映射

### 缓存策略
- **因子缓存**: 计算结果必须缓存
- **数据缓存**: 常用数据内存缓存
- **智能失效**: 基于数据变化的缓存失效

## 🔍 性能监控要求

### 关键指标监控
```python
# 实时性能监控
class PerformanceMonitor:
    def __init__(self):
        self.metrics = {
            'calculation_time': [],
            'memory_usage': [],
            'cache_hit_rate': [],
            'error_count': []
        }

    def monitor_calculation(self, func_name, start_time, end_time, memory_usage):
        execution_time = end_time - start_time
        self.metrics['calculation_time'].append(execution_time)
        self.metrics['memory_usage'].append(memory_usage)

        # 性能告警
        if execution_time > TARGET_TIME:
            self.alert_slow_function(func_name, execution_time)
        if memory_usage > MEMORY_LIMIT:
            self.alert_high_memory(func_name, memory_usage)
```

### 性能回归测试
- **基准测试**: 定期运行性能基准测试
- **回归检测**: 新版本不能降低性能
- **性能分析**: 识别性能瓶颈
- **优化建议**: 提供具体优化建议

## ⚠️ 性能违规检测

### 常见性能问题
```python
# ❌ 性能反模式
def slow_factor_calculation(data):
    results = []
    for factor in data.columns:
        # 逐个计算，性能差
        result = expensive_calculation(data[factor])
        results.append(result)
    return results

# ✅ 性能优化模式
def fast_factor_calculation(data):
    # 批量向量化计算
    return vectorbt.Portfolio.from_signals(data).stats()
```

### 内存泄漏检测
- **对象引用**: 检查循环引用
- **内存增长**: 监控内存使用增长趋势
- **垃圾回收**: 及时释放大对象
- **内存碎片**: 避免频繁的内存分配/释放

### 计算复杂度检查
- **时间复杂度**: 算法复杂度分析
- **空间复杂度**: 内存使用复杂度评估
- **嵌套循环**: 避免深层嵌套循环
- **递归调用**: 递归深度和栈空间管理

## 📈 性能优化策略

### 算法优化
- **向量化**: 使用 NumPy/VectorBT 向量化操作
- **并行化**: 利用多核处理器
- **预计算**: 预计算可重用的中间结果
- **延迟计算**: 按需计算，避免不必要计算

### 数据结构优化
- **内存布局**: 优化数据内存布局
- **数据类型**: 使用适当的数据类型
- **索引优化**: 优化数据访问模式
- **缓存友好**: 设计缓存友好的数据结构

### 编译优化
- **JIT编译**: 使用 Numba JIT 加速
- **C扩展**: 关键函数 C 扩展
- **Cython**: Cython 优化关键路径
- **并行库**: 使用高性能并行库

## 🎯 性能达标验证

### 性能测试流程
1. **基准测试**: 建立性能基准线
2. **回归测试**: 验证性能不退化
3. **压力测试**: 大规模数据测试
4. **优化验证**: 优化效果验证
5. **持续监控**: 生产环境性能监控

### 性能报告要求
- **执行时间**: 详细执行时间分析
- **内存使用**: 内存使用分析和优化建议
- **瓶颈识别**: 性能瓶颈识别和解决方案
- **优化建议**: 具体优化建议和实施计划

### 性能改进计划
- **短期优化**: 立即可实施的优化措施
- **中期优化**: 需要设计和实施的优化
- **长期优化**: 架构级别的性能优化
- **持续改进**: 建立持续性能改进机制

## 🔧 性能工具配置

### 性能分析工具
```python
# 性能分析工具配置
PROFILING_TOOLS = {
    'cProfile': 'Python内置性能分析器',
    'memory_profiler': '内存使用分析器',
    'line_profiler': '代码行级性能分析',
    'py-spy': 'Python性能分析工具'
}
```

### 监控仪表板
- **实时监控**: 实时性能指标监控
- **历史趋势**: 性能历史趋势分析
- **告警机制**: 性能问题自动告警
- **可视化报告**: 性能数据可视化展示

这些性能约束确保系统满足量化交易的高性能要求，支持实时交易决策。