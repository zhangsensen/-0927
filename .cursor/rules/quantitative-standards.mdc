---
alwaysApply: false
---

# Quantitative Engineering Standards
# 专业量化开发约束和最佳实践

## 🎯 核心量化原则

### 154指标系统规范
- **技术指标分类**: 36个核心 + 118个增强指标
- **计算准确性**: 每个指标必须通过数值稳定性测试
- **性能要求**: 向量化实现，避免循环计算
- **数值验证**: 边界条件、极值、异常值处理

### 因子筛选5维度框架
1. **预测能力 (35%权重)**: 多周期IC分析 (1,3,5,10,20天)
2. **稳定性 (25%权重)**: 滚动窗口IC一致性
3. **独立性 (20%权重)**: VIF多重共线性检测
4. **实用性 (15%权重)**: 交易成本和换手率分析
5. **短期适应性 (5%权重)**: 动量持续性和反转效应

### 统计显著性严格标准
- **Benjamini-Hochberg FDR校正**: 必须应用，α = 0.01, 0.05, 0.10
- **IC显著性阈值**: |IC| > 0.02 且 p < 0.05
- **样本量要求**: 最小100个观测值，推荐200+
- **稳定性检验**: 滚动窗口验证，标准差 < 0.1

## 🔬 偏差防护体系

### 时间序列偏差防护
```python
# ✅ 正确: 无未来函数
def calculate_ic(factor, returns, lag=1):
    factor_aligned = factor[:-lag]  # 移除末尾
    returns_aligned = returns[lag:]  # 移除开头
    return stats.spearmanr(factor_aligned, returns_aligned)

# ❌ 错误: 存在未来函数
def calculate_ic_wrong(factor, returns):
    return stats.spearmanr(factor, returns.shift(-1))  # 未来数据泄露
```

### 存活者偏差防护
- **全市场包含**: 必须包含已退市公司历史数据
- **重新平衡**: 定期重新构建投资组合
- **权重调整**: 根据市值变化调整权重

### 数据窥探防护
- **参数限制**: 最多3次参数调整周期
- **样本外验证**: 必须有独立的验证集
- **时间分隔**: 严格的数据时间分离

## ⚡ 性能优化约束

### VectorBT 集成要求
- **向量化优先**: 10-50x性能提升
- **内存效率**: 40-60%内存使用减少
- **批量处理**: 避免逐个因子计算
- **并行计算**: 利用多核处理器

### 内存管理规范
```python
# ✅ 高效: 批量计算
def batch_calculate_factors(factors_data):
    with vectorbt.Replayer() as replay:
        portfolio = vbt.Portfolio.from_signals(factors_data)
        return portfolio.stats()

# ❌ 低效: 逐个计算
def sequential_calculate_factors(factors_data):
    results = {}
    for factor_name, factor_data in factors_data.items():
        results[factor_name] = slow_calculation(factor_data)
    return results
```

### 缓存策略
- **因子缓存**: 计算结果缓存，避免重复计算
- **数据缓存**: 市用数据结构内存缓存
- **LRU机制**: 最近最少使用算法

## 📊 数据质量标准

### 原始数据要求
- **数据源质量**: Yahoo Finance, Wind, Bloomberg等可靠源
- **时间精度**: 分钟级数据精确到秒
- **数据完整性**: 无缺失值处理机制
- **异常值检测**: 自动识别和处理异常价格

### 数据验证检查清单
- [ ] 价格数据连续性 (无时间间隙)
- [ ] 成交量数据合理性 (非负值)
- [ ] 价格一致性 (高低开收盘关系)
- [ ] 时间戳对齐 (多数据源同步)
- [ ] 货务日历准确性 (排除非交易日)

## 🧮 数学计算精度

### 数值稳定性
```python
# ✅ 稳定: 添加数值保护
def calculate_sharpe(returns, risk_free_rate=0.02):
    excess_returns = returns - risk_free_rate / 252
    volatility = np.std(excess_returns) + 1e-8  # 避免除零
    return np.mean(excess_returns) / volatility

# ❌ 不稳定: 可能除零
def calculate_sharpe_unstable(returns, risk_free_rate=0.02):
    return (np.mean(returns) - risk_free_rate) / np.std(returns)
```

### 统计计算规范
- **相关性**: Spearman秩相关，稳健性优于Pearson
- **回归分析**: 使用稳健回归方法
- **假设检验**: 非参数方法优先，减少分布假设
- **置信区间**: Bootstrap方法计算经验置信区间

## 🏛️ 架构设计原则

### 模块化设计
```
factor_system/
├── generation/          # 因子计算模块
│   ├── technical/       # 技术指标计算
│   ├── fundamental/    # 基本面因子
│   └── alternative/     # 另类因子
├── screening/          # 因子筛选模块
│   ├── statistics/      # 统计分析
│   ├── validation/      # 有效性验证
│   └── ranking/         # 排序打分
├── backtesting/        # 回测模块
│   ├── execution/       # 交易执行
│   ├── risk/           # 风险管理
│   └── performance/     # 性能分析
└── utils/              # 工具模块
    ├── data/           # 数据处理
    ├── math/           # 数学工具
    └── validation/     # 验证工具
```

### 接口设计标准
- **统一接口**: 标准化的因子和回测接口
- **配置驱动**: 参数通过配置文件管理
- **插件化**: 支持自定义因子和策略
- **版本兼容**: 向后兼容的API设计

## 🔍 代码审查重点

### 因子计算审查
- **算法正确性**: 数学公式实现准确
- **边界条件**: 极值、空值、异常值处理
- **性能效率**: 计算复杂度合理
- **可重现性**: 固定随机种子

### 统计检验审查
- **方法适当性**: 统计方法选择合理
- **假设验证**: 检验统计假设成立
- **多重比较**: 正确处理多重比较问题
- **效应大小**: 不仅看显著性，关注实际效果

### 风险管理审查
- **风险指标计算**: VaR、CVaR、最大回撤准确
- **压力测试**: 极端市场情况下的表现
- **流动性分析**: 交易量和市场深度考虑
- **集中度风险**: 多样化效果评估

## 🚫 严格禁止模式

### 数据操作禁忌
- **未来数据使用**: 严禁在回测中使用未来信息
- **选择性删除**: 不得删除不利的历史数据
- **参数过度优化**: 避免数据窥探和过拟合
- **样本外使用**: 严禁用样本内结果指导样本外决策

### 计算禁忌
- **硬编码参数**: 所有参数必须配置化
- **精度损失**: 避免不必要的数值精度损失
- **累积误差**: 控制累积误差范围
- **近似计算**: 评估近似计算误差影响

遵循这些标准，确保量化系统的科学性、可靠性和实用性。质量永远是第一优先级。# Quantitative Engineering Standards
# 专业量化开发约束和最佳实践

## 🎯 核心量化原则

### 154指标系统规范
- **技术指标分类**: 36个核心 + 118个增强指标
- **计算准确性**: 每个指标必须通过数值稳定性测试
- **性能要求**: 向量化实现，避免循环计算
- **数值验证**: 边界条件、极值、异常值处理

### 因子筛选5维度框架
1. **预测能力 (35%权重)**: 多周期IC分析 (1,3,5,10,20天)
2. **稳定性 (25%权重)**: 滚动窗口IC一致性
3. **独立性 (20%权重)**: VIF多重共线性检测
4. **实用性 (15%权重)**: 交易成本和换手率分析
5. **短期适应性 (5%权重)**: 动量持续性和反转效应

### 统计显著性严格标准
- **Benjamini-Hochberg FDR校正**: 必须应用，α = 0.01, 0.05, 0.10
- **IC显著性阈值**: |IC| > 0.02 且 p < 0.05
- **样本量要求**: 最小100个观测值，推荐200+
- **稳定性检验**: 滚动窗口验证，标准差 < 0.1

## 🔬 偏差防护体系

### 时间序列偏差防护
```python
# ✅ 正确: 无未来函数
def calculate_ic(factor, returns, lag=1):
    factor_aligned = factor[:-lag]  # 移除末尾
    returns_aligned = returns[lag:]  # 移除开头
    return stats.spearmanr(factor_aligned, returns_aligned)

# ❌ 错误: 存在未来函数
def calculate_ic_wrong(factor, returns):
    return stats.spearmanr(factor, returns.shift(-1))  # 未来数据泄露
```

### 存活者偏差防护
- **全市场包含**: 必须包含已退市公司历史数据
- **重新平衡**: 定期重新构建投资组合
- **权重调整**: 根据市值变化调整权重

### 数据窥探防护
- **参数限制**: 最多3次参数调整周期
- **样本外验证**: 必须有独立的验证集
- **时间分隔**: 严格的数据时间分离

## ⚡ 性能优化约束

### VectorBT 集成要求
- **向量化优先**: 10-50x性能提升
- **内存效率**: 40-60%内存使用减少
- **批量处理**: 避免逐个因子计算
- **并行计算**: 利用多核处理器

### 内存管理规范
```python
# ✅ 高效: 批量计算
def batch_calculate_factors(factors_data):
    with vectorbt.Replayer() as replay:
        portfolio = vbt.Portfolio.from_signals(factors_data)
        return portfolio.stats()

# ❌ 低效: 逐个计算
def sequential_calculate_factors(factors_data):
    results = {}
    for factor_name, factor_data in factors_data.items():
        results[factor_name] = slow_calculation(factor_data)
    return results
```

### 缓存策略
- **因子缓存**: 计算结果缓存，避免重复计算
- **数据缓存**: 市用数据结构内存缓存
- **LRU机制**: 最近最少使用算法

## 📊 数据质量标准

### 原始数据要求
- **数据源质量**: Yahoo Finance, Wind, Bloomberg等可靠源
- **时间精度**: 分钟级数据精确到秒
- **数据完整性**: 无缺失值处理机制
- **异常值检测**: 自动识别和处理异常价格

### 数据验证检查清单
- [ ] 价格数据连续性 (无时间间隙)
- [ ] 成交量数据合理性 (非负值)
- [ ] 价格一致性 (高低开收盘关系)
- [ ] 时间戳对齐 (多数据源同步)
- [ ] 货务日历准确性 (排除非交易日)

## 🧮 数学计算精度

### 数值稳定性
```python
# ✅ 稳定: 添加数值保护
def calculate_sharpe(returns, risk_free_rate=0.02):
    excess_returns = returns - risk_free_rate / 252
    volatility = np.std(excess_returns) + 1e-8  # 避免除零
    return np.mean(excess_returns) / volatility

# ❌ 不稳定: 可能除零
def calculate_sharpe_unstable(returns, risk_free_rate=0.02):
    return (np.mean(returns) - risk_free_rate) / np.std(returns)
```

### 统计计算规范
- **相关性**: Spearman秩相关，稳健性优于Pearson
- **回归分析**: 使用稳健回归方法
- **假设检验**: 非参数方法优先，减少分布假设
- **置信区间**: Bootstrap方法计算经验置信区间

## 🏛️ 架构设计原则

### 模块化设计
```
factor_system/
├── generation/          # 因子计算模块
│   ├── technical/       # 技术指标计算
│   ├── fundamental/    # 基本面因子
│   └── alternative/     # 另类因子
├── screening/          # 因子筛选模块
│   ├── statistics/      # 统计分析
│   ├── validation/      # 有效性验证
│   └── ranking/         # 排序打分
├── backtesting/        # 回测模块
│   ├── execution/       # 交易执行
│   ├── risk/           # 风险管理
│   └── performance/     # 性能分析
└── utils/              # 工具模块
    ├── data/           # 数据处理
    ├── math/           # 数学工具
    └── validation/     # 验证工具
```

### 接口设计标准
- **统一接口**: 标准化的因子和回测接口
- **配置驱动**: 参数通过配置文件管理
- **插件化**: 支持自定义因子和策略
- **版本兼容**: 向后兼容的API设计

## 🔍 代码审查重点

### 因子计算审查
- **算法正确性**: 数学公式实现准确
- **边界条件**: 极值、空值、异常值处理
- **性能效率**: 计算复杂度合理
- **可重现性**: 固定随机种子

### 统计检验审查
- **方法适当性**: 统计方法选择合理
- **假设验证**: 检验统计假设成立
- **多重比较**: 正确处理多重比较问题
- **效应大小**: 不仅看显著性，关注实际效果

### 风险管理审查
- **风险指标计算**: VaR、CVaR、最大回撤准确
- **压力测试**: 极端市场情况下的表现
- **流动性分析**: 交易量和市场深度考虑
- **集中度风险**: 多样化效果评估

## 🚫 严格禁止模式

### 数据操作禁忌
- **未来数据使用**: 严禁在回测中使用未来信息
- **选择性删除**: 不得删除不利的历史数据
- **参数过度优化**: 避免数据窥探和过拟合
- **样本外使用**: 严禁用样本内结果指导样本外决策

### 计算禁忌
- **硬编码参数**: 所有参数必须配置化
- **精度损失**: 避免不必要的数值精度损失
- **累积误差**: 控制累积误差范围
- **近似计算**: 评估近似计算误差影响

遵循这些标准，确保量化系统的科学性、可靠性和实用性。质量永远是第一优先级。