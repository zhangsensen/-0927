# 即时因子回测极简方案

## 背景与问题

当前 `factor_system` 项目采用**批量因子计算 + 持久化存储**的设计，适合因子研究，但存在以下问题：

- 存储爆炸：154 列 × 股票数 × 日期数
- 因子文件冗余：大量未通过显著性检验的因子也被存储
- 回测复杂性：需要从因子文件中读取、对齐、融合

## 极简方案核心思想

**即时计算、算完即走、不存储因子**

- 每个股票在回测时即时计算 154 因子
- 只保留通过显著性检验的有效因子
- 无持久化因子存储，避免存储爆炸

## 架构设计

### 方案选择：研究 & 回测分离

```
factor_system/          # 保持现状，用于因子研究
│
└─ hk_midfreq/          # 新的极简回测系统
   ├─ price_loader.py                 # ✅ 已有
   ├─ on_the_fly_factor_engine.py    # 🆕 即时因子计算引擎
   ├─ strategy_core.py               # ✅ 已有，需改造
   └─ multi_factor_strategy.py       # ✅ 已有，需改造
```

**优点**：
- 不破坏现有 `factor_system` 的研究价值
- 用途分离：研究归研究，回测归回测
- 最小改动，新增模块即可实现

## 实现计划

### 第一步：新增即时因子引擎

**文件**：`hk_midfreq/on_the_fly_factor_engine.py`

**功能**：
- 调用 `factor_system.factor_generation` 的 154 指标函数
- 即时计算所有因子
- 过显著性检验（IC 分析）
- 只返回有效因子（可选前 N 名）

**接口设计**：
```python
class OnTheFlyFactorEngine:
    def compute_factors(self, price_df: pd.DataFrame, symbol: str) -> pd.DataFrame:
        """
        即时计算因子并过滤
        
        Args:
            price_df: OHLCV 数据
            symbol: 股票代码
            
        Returns:
            有效因子 DataFrame
        """
        pass
```

### 第二步：改造多因子策略

**文件**：`hk_midfreq/multi_factor_strategy.py`

**改动**：
- 移除因子文件加载逻辑
- 改为调用 `OnTheFlyFactorEngine`
- 保持价格加载逻辑不变

**改动前后对比**：
```python
# 改动前
factor_df = self.load_factor_file(symbol, timeframe)
merged_df = pd.concat([price_df, factor_df], axis=1)

# 改动后
factor_engine = OnTheFlyFactorEngine()
factor_df = factor_engine.compute_factors(price_df, symbol)
merged_df = pd.concat([price_df, factor_df], axis=1)
```

### 第三步：优化与验证

- 性能测试：单只股票即时计算时间
- 验证测试：与原有因子计算结果一致性
- 内存优化：确保计算后及时释放内存

## 技术实现细节

### 即时因子计算流程

```python
def compute_factors(self, price_df: pd.DataFrame, symbol: str) -> pd.DataFrame:
    # 1. 调用 factor_system 生成所有 154 因子
    all_factors = self._generate_all_factors(price_df)
    
    # 2. 显著性检验
    significant_factors = self._significance_test(all_factors, price_df)
    
    # 3. 选择有效因子
    valid_factors = self._select_valid_factors(significant_factors)
    
    return valid_factors
```

### 显著性检验参数

- IC 分析窗口：20 日滚动窗口
- 显著性阈值：p < 0.05
- 因子数量限制：最多保留前 20 个有效因子

### 性能优化策略

- 缓存因子函数对象，避免重复导入
- 使用 numba 加速关键计算
- 及时清理中间变量，控制内存使用

## 优势分析

### ✅ 工程优势

1. **极简存储**：无因子文件，无存储爆炸
2. **真实模拟**：像实盘一样即时计算因子
3. **灵活实验**：随时调整因子逻辑，无需清库
4. **扩展性强**：加几千个股票也不怕

### ✅ 量化优势

1. **避免未来函数**：每只股票独立计算，无交叉污染
2. **真实回测**：因子与价格严格对齐
3. **参数灵活**：显著性阈值可动态调整

## 风险与注意事项

### ⚠️ 计算性能

- 每只股票都要计算 154 因子，需要优化性能
- 建议使用 numba 加速，避免 Python 循环

### ⚠️ 因子一致性

- 确保即时因子计算与 factor_system 结果一致
- 需要做一致性验证测试

### ⚠️ 内存管理

- 及时释放计算过程中的中间变量
- 监控内存使用，避免内存泄漏

## 实施时间线

### 第一阶段（1-2 天）
- [ ] 实现 `OnTheFlyFactorEngine` 基础框架
- [ ] 调用 factor_system 指标函数
- [ ] 基础显著性检验

### 第二阶段（1 天）
- [ ] 改造 `multi_factor_strategy.py`
- [ ] 移除因子文件加载
- [ ] 集成即时因子引擎

### 第三阶段（1 天）
- [ ] 性能测试与优化
- [ ] 一致性验证
- [ ] 文档更新

## 长期演进

### 可选优化方向

1. **轻量缓存**：缓存因子计算结果，避免重复计算
2. **并行计算**：多股票并行计算因子
3. **增量计算**：只计算新增日期的因子

### 扩展可能性

- 支持多种因子计算引擎
- 支持实时因子计算
- 集成机器学习因子筛选

## 结论

这个极简方案遵循 Linus 式工程哲学：

- **消灭复杂性**：去掉因子存储，直接即时计算
- **实用主义**：解决真实问题，避免过度设计
- **API 兼容性**：保持现有策略接口不变
- **简洁执念**：最少的代码实现最大的功能

推荐立即实施这个方案，实现真正的极简量化回测系统。